### 冒泡排序学习笔记

| 时间 | 笔记 |
|---|---|
|2019.1.14|编写算法时，变量名的命名要有含义，便于理解。
|2019.1.16|冒泡排序的遍历，可以是从前到后扫描，也可以是从后到前扫描。这里采用的是从前到后扫描的办法。默认采用的排序是升序排序。


例如：在循环里面，将第一个for循环的变量命名为end.

### 选择排序学习笔记

| 时间 | 笔记 |
|---|---|
|2019.1.14|编写算法时，变量名的命名要有含义，便于理解。
|  | 例如：最小变量的下标，写做minIndex要比写作min更加好，不容易导致代码逻辑错误。
|2019.1.16|选择排序和冒泡排序有相似之处，但是不一样。选择排序在选择最小值的过程中，不用两两交换，只需要遍历一遍，找到每一轮中的最小值即可。
|  | 在这次复习中，对于for 循环的边界条件，出现了错误。应该为i< arr.length 写成了 i < arr.length -1.
|  | 所以，在写算法的时候，边界条件需要特别注意。


### 插入序学习笔记

| 时间 | 笔记 |
|---|---|
|2019.1.14|注意插入排序中的插入，是在数组中实现的。插入需要通过交换来实现
|2019.1.16|插入排序的一个重要特点，是将其看做前面有序。|
|   |这里需要注意，插入操作，是从有序序列中的后面，依次向前做交换，实现插入的目的|
例如：1,2,3,0
将 0 插入序列1,2,3中，需要经过以下步骤：

1,2,0,3

1,0,2,3

0,1,2,3


### 归并排序笔记

在这个目录里面，首先使用递归的形式，实现了一个求取数组中最大值的方法。
这是因为，在归并排序里面，用到了递归的方法。递归，其实包含着分治的思想。

**递归**的实现，是由系统中将运行环境进行压栈而实现的。
在递归程序里面，包含着两大要素：一个是递归退出条件，另一个是程序中需包含对自身的调用。

**归并排序**，主要是用递归的形式来实现的。这里面体现的是算法中的分治思想。

基本步骤为：

- 将数组分为左右两个部分
- 左边排好序
- 右边排好序
- 左右两边合并

其中，要设立一个help数组，所以项目中的空间复杂度为O(n).
归并排序中的排序，主要是在merge 的过程中实现的。

| 时间 | 笔记 |
|---|---|
|2019.1.16 S02|记住归并排序的最本质的思想，将原问题划分为若干个相同类型的小规模问题，也就是需要partition|
|   |归并的过程中，主要注意边界条件，以及复制数组是的起点，应该是left,而不是从0开始。|




### 最小和问题

在一个数组中，每一个数的左边比它小的数累加起来的和，叫做最小和。
求一个数组中的最小和。

基本思路：

1. 思路一：等价于找每一个数的右边的比这个数要大的数的个数。然后乘以当前数。

2. 思路二：结合排序来解题。在排序的过程中，完成计算最小和的任务。

| 时间 | 笔记 |
|---|---|
|2019.1.17 S02|这题的新颖之处，在于使用排序的方法来实现对最小和的求解。这不是唯一解|
|   |简洁代码的书写值得学习，如下：|
|   我的版本|简洁代码的书写值得学习，如下：|
```while (p1 <= mid && p2 <= right){
                   if (arr[p1] < arr[p2]){
                       result += arr[p1] * (right - p2 + 1);
                       help[i++] = arr[p1++];
                   }else {
                       help[i++] = arr[p2++];
                   }
               } 
```

|  |  |
|---|---|
|  | 别人的代码 |  
```$xslt
 while (p1 <= m && p2 <= r){
            res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] :0; //这一行代码未想出来！
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }

```      
           

### 数组分离问题

给定一个数组arr，和一个数num。
请将小于num的数放在数组的左边。大于num的数，放在数组的右边。
要求额外空间复杂度O(1)，时间复杂度O(N)

 
基本思路

 时间 | 笔记 |
|---|---|
|2019.1.17|数组划分与荷兰国旗是两个问题，主要是划分的条件不一致。
|   |这里，排序后，只能保证数字分散在枢轴的两侧，而两侧的数字，并不是有序的|
|   |在写代码的时候，一定要经过多次测试，不然很难保证程序的正确性|


### 荷兰国旗问题

因为荷兰国旗主要是三种颜色。本题中，是要将数组进行三段的划分，所以叫做荷兰国旗问题。

要点：

- 设置变量来表示趋于的边界：less、more、cur
- 当cur小于num时，发生交换，并且cur的指针向后移动。
- 当cur大于num是，发生交换，但是此时cur的指针不移动，而是继续和num比较
        这是因为cur是从左向右扫描的。和右边发生交换后，cur所指的值，是一个新的
        值。所以，不能向后移动。 
        
        
基本的视图

| 小于区 | 等于区 | 待定区 | 大于区 |


 时间 | 笔记 |
|---|---|
|2019.1.19|荷兰国旗问题,注意判断循环终止的条件为：cur < more
|   |其次，这次使用了对数器的方式，来检查自己代码的完备性与强壮型。|

### 快速排序

快速排序分为普通快排和随机快排

基本思想

- 综合和划分和递归这两种手段。
- 首先是划分 partition，然后是对剩余部分进行递归调用partition

写代码前的想法：

选取最后一个数，作为Partition的枢轴。

递归的操作：
- 首先，是选择枢轴
- 按照枢轴进行划分
- 获得等于区域的范围


- 对左侧部分进行划分
- 对右侧部分进行划分
- 返回最终的结果。


写代码的过程中，一定要保证思路是正确的。而代码，就是表示思路的清晰度。

思路不清晰，盲目写代码，之后导致自己瞎调试，浪费大量的时间。

所以，写代码的时候，一定要全神贯注。

| 时间 | 笔记 |
|---|---|
|2019.1.18 |快速排序，用到了递归。注意，这里的递归出口为： if(l > r)|
|   | 快速排序，用到的就是，划分！使用不断的划分，实现数组的有序|
